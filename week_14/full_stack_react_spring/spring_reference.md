# Spring Reference Sheet
This guide is intended to act as a quick reference in helping you write your Spring applications. It is only intended to contain content pertinent to the course content and is not intended to be exhaustive.

If you want to learn more about Spring, check out the additional resources listed at the bottom of the document [here](#additional-resources).

## Contents
1. [Spring configuration](#spring-configuration)
    - [Common application.properties settings](#common-applicationproperties-settings)
2. [The Spring Boot application class](#the-spring-boot-application-class)
3. [Custom Spring application runner](#custom-spring-application-runner)
4. [Spring profiles](#spring-profiles)
5. [Model classes](#model-classes)
6. [Model properties](#model-properties)
    - [One to many relationships](#one-to-many-relationships)
    - [Many to one relationships](#many-to-one-relationships)
    - [Many to many relationships](#many-to-many-relationships)
    - [Custom join tables to handle many-to-many relationships](#custom-join-tables-to-handle-many-to-many-relationships)
    - [Controlling infinite recursion when serializing to JSON](#controlling-infinite-recursion-when-serializing-to-json)
    - [Do I need to have and annotate properties on both sides of a relationship?](#do-i-need-to-have-and-annotate-properties-on-both-sides-of-one-to-many-many-to-one-and-many-to-many-relationships)
7. [Repository interfaces](#repository-interfaces)
    - [Derived queries](#derived-queries)
    - [Custom queries](#custom-queries)
8. [Controller annotations](#controller-annotations)
    - [Accessing a URL path variable](#accessing-a-url-path-variable)
    - [Accessing the request body](#accessing-the-request-body)
    - [Accessing query parameters](#accessing-query-parameters)
9. [Test annotations](#test-annotations)
10. [Spring components](#spring-components)
11. [Dependency injection annotation](#dependency-injection-annotation)
12. [Additional resources](#additional-resources)

## Spring configuration
Spring applications and their components can be configured in Java code through classes annotated with `@Configuration` however commonly we use an `application.properties` file situated in the `src/main/resources` folder to tell Spring what configuration properties to use. We can also place an application.properties file in the `src/test/resources` folder to specify test-specific configurations.

### Common application.properties settings
The following specifies the connection string Spring should use to connect to the underlying database and the correct SQL dialect which Spring should use to auto-generate SQL queries:

```toml
spring.datasource.url=jdbc:postgresql://localhost:5432/<your_db_name>
spring.jpa.database-platform=org.hibernate.dialect.PostgreSQL9Dialect
```

Note that here jdbc (Java Database Connectivity) is the interface Spring will use to connect to your database. postgresql is the driver it will use to connect (because we're connecting to a PostgreSQL database - if we used a different database service we would need to change this). We specify `localhost:5432` because we're connecting to the locally running PostgreSQL service which by default runs on port 5432. We set the dialect to `PostgreSQL9Dialect` to ensure that the SQL queries generated by Spring are appropriate for working with PostgreSQL v9 and above.

The following properties set the username and password Spring should use to connect to the database:

```toml
spring.datasource.username=postgres
spring.datasource.password=postgres
```

The following property controls how Spring and Hibernate auto generates (and executes) DDL (Database Definition Language) to create/update table structures at application startup:

```toml
spring.jpa.hibernate.ddl-auto=update
```

Valid values for this setting are:

- **create** – Drop all tables and then create them.
- **update** – If the Java model classes have changed (e.g. added new properties, changed types, changed annotations) update the table structure already in the DB.
- **create-drop** – Same as the create setting but in addition the database tables will be dropped after all operations have been completed and the application is stopped.
- **validate** – Does no dropping/creation, just validates that relevant tables and columns exist in the correct form.
- **none** – Turns off DDL generation.

The following setting supports Spring and Hibernate being able to load related entities (e.g. those annotated with `@OneToMany`, `@ManyToOne`, `@ManyToMany`) by starting a new transaction for each separate query it requires - if this is not set, you many encounter a `LazyInitializationException` when querying entities with relationships to others. See [here](https://www.baeldung.com/hibernate-lazy-loading-workaround) if you want to know more.

```toml
spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true
```

The following setting allows us to specify that all REST controller endpoint URL mappings should be relative to a given path, in this case `/api`, thus if we have a controller with a URL mapping value of `/pirates`, incoming requests will only be mapped if they use URL `/api/pirates`:

```toml
server.servlet.context-path=/api
```

## The Spring Boot application class
The main Spring Boot application class (which will be created for you automatically if you use the Spring Initialzr website to create your project) should be located in the top-most level of your `src/main/java` package structure and should be annotated with `@SpringBootApplication`.

The `@SpringBootApplication` annotation actually comprises three other annotations behind the scenes which enable automatic configuration of your project, specify the application class as being a configuration class itself and allowing Spring to scan the project for Spring components, repositories etc (hence we ensure this application class is at the top-level, so any other code we write will be found by the scanning process).

We normally have our `public static void main(String[] args) {}` method in this class as the entrypoint into our application and accordingly use Spring's built in `SpringApplication.run` method inside of it to ask Spring to run the Spring Boot application:

```java
@SpringBootApplication
public class PirateserviceApplication {

	public static void main(String[] args) {
		SpringApplication.run(PirateserviceApplication.class, args);
	}
}
```

## Custom Spring application runner
By creating a class which implements the Spring `ApplicationRunner` interface and annotating it with `@Component` we can add custom actions when Spring starts our application, such as loading data. When implementing this interface, we need to implement the `run` method, into which we can carry out our custom actions. For example:

```java
@Component
public class CustomRunner implements ApplicationRunner {
    public void run(ApplicationArguments args) {
        // code custom actions here
    }
}
```

## Spring profiles
We may wish for a particular component class only to be instantiated by Spring when we've activated a specific profile - for example only instantiate a data loader class when we're not running unit tests and the current profile is set to `test`.

To facilitate this, we can annotate such classes with the `@Profile` annotation to specify under which profile we should (or should not) create an instance of the class.

For example, the following will only be created by Spring when the `test` profile is active:

```java
@Profile("test")
@Component
public class MyClass {
  ...
}
```

Whereas the following will only be created by Spring when the `test` profile is NOT active:

```java
@Profile("!test")
@Component
public class MyClass {
  ...
}
```

In order to activate a given profile, we could add a configuration to the application.properties file - the following example sets the active profile to `dev` (this is an arbitrary name decided by us):

```toml
spring.profiles.active=dev
```

The same thing can be achieved by passing a command line argument to the JVM when executing manually in the terminal (we can also do this when running in IntelliJ by editing the run configuration):

```
-Dspring.profiles.active=dev
```

In unit testing, we can use the `@ActiveProfile` annotation on a test class - see the section on test annotations [here](#test-annotations).

## Model classes
When defining a POJO (Plain Old Java Object) model class to model the properties of your entity's data and you wish Spring to be able to manage these entities via a repository, you should annotate your model class with the `@Entity` annotation. This also means you need to specify your model's primary key, which we do by annotation the primary key property with `@Id`. 

In the following example, the primary key is a `Long` (64-bit integer) and we additionally annotate the property with `@GeneratedValue(strategy = GenerationType.IDENTITY)` to indicate that instead of us as the developer manually assigning the value for this property, the underlying database will assign this automatically.

We also annotate the class with `@Table` which allows us to explicitly set the name which should be used for the corresponding database table (note that we can leave out this annotation, in which case the default table name will be the same as the class name - however convention is usually pluralised table name, hence we set it manually):

```java
import javax.persistence.*;

@Entity
@Table(name = "pirates")
public class Pirate {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    ...
}
```

## Model properties
By default, any property inside a class annotated with `@Entity` will be mapped by Spring to/from a database table, where it will expect there to be a column name in the appropriate table matching the property name but in lower snake-case form. For example, Spring will expect there to be columns called `name` and `country_of_residence` in the corresponding database table:

```java
@Entity
public class Customer {
  ...
  private String name;
  private String countryOfResidence;

}
```

However, we can customise the name Spring will map properties to in the database by using the `@Column` annotation:

```java
@Entity
public class Customer {
  ...
  @Column(name = "cust_name")
  private String name;
  @Column(name = "country")
  private String countryOfResidence;
}
```

Here we expect Spring to map the fields to database columns of `cust_name` and `country` respectively.

There are various other attributes we can configure using the `@Column` annotation but commonly we may wish to specify whether or not the field can be null. By default, this is set to `true`, e.g. can be empty, but we can make it mandatory using the `nullable` argument. In the following example `name` is mandatory but `countryOfResidence` is optional:

```java
@Entity
public class Customer {
  ...
  @Column(nullable = false)
  private String name;
  @Column
  private String countryOfResidence;
}
```

### One to many relationships
In order to support being able to get access to the related entity in a one-to-many relationship, e.g. we're in the Ship class and one ship can be associated with many Pirates, we can annotate the property referring to the 'many' in the many-to-one relationship, in this case Pirate, with `@OneToMany`. When we do this, we should also specify the name of the property on the related class which points back to the class in which we're using the `@OneToMany` annotation - for example in the case of the Ship's pirates property, the related property name on the Pirate class which points back to the Ship class is `ship`.

In this example, we specify that the Ship entity has a one-to-many relationship with the Pirate entity. We also pass a `mappedBy` argument, which is the name of the property on the related class which points back to the Ship class:

```java
public class Ship {
    ...

    @OneToMany(mappedBy = "ship")
    private List<Pirate> pirates;

    ...
}
```

And we can see on the corresponding Pirate class there is a `ship` property which is of type Ship (so points back to the Ship entity) and is annotated with `@ManyToOne` since it is on the `many` end of the one-to-many relationship:

```java
@Entity

public class Pirate {
    ...

    @ManyToOne
    @JoinColumn(name = "ship_id", nullable = false)
    private Ship ship;
    
    ...
}
```

### Many to one relationships
In order to support being able to get access to the related entity in a many-to-one relationship, e.g. we're in the Pirate class and many Pirates can be associated with one Ship, we can annotate the property referring to the 'one' in the many-to-one relationship, in this case Ship, with `@ManyToOne`. When we do this, we should also annotate the property with the `@JoinColumn` annotation allowing us to specify the name of the database column on the 'many' end of the many-to-one relationship (in this case the Pirate entity) which should act as the foreign key.

In this example, we specify that the Pirate table should have a foreign key `ship_id` pointing to a single Ship entity. We also specify that it is not nullable, meaning it must have a value (the default value for the `nullable` property if we don't explicitly set it is `true`, meaning it allows empty values).

```java
@Entity
public class Pirate {
  @ManyToOne
  @JoinColumn(name = "ship_id", nullable = false)
  private Ship ship;

  ...
}
```

### Many to many relationships
In order to support many-to-many relationships between two entity types and be able to access entities on the other side of the relationship, e.g. we're in the Raid class and many Pirates can be associated with many Raids, we can annotate such fields with `@ManyToMany`. When we do this, we should also specify details of the join table which Spring should use to handle the many-to-many relationship. We do this using the `@JoinTable` annotation. Note that Hibernate will automatically generate this join table for us - we don't have to worry about adding our own class and annotating it with `@Entity`/`@Table`

The `@JoinTable` annotation allows us to specify:
- The name of the join table which Hibernate should use to persist the relationship between each entity in the many-to-many relationship, e.g. in the case of Raid and Pirate, `pirates_raids`.
- The joinColumns which should be used in the join table (this is really the name of a column relating to the class in which we're using the annotation, e.g. if we're in the Raid class, a `@JoinColumn` annotation with a name of `raid_id` will allow the join table to point to a single row in the Raid table).
- The inverseJoinColumns which should be used in the join table (this is really the name of a column relating to the class on the other side of the many-to-many relationship to the class we're using the annotation, e.g. if we're in the Raid class, a `@JoinColumn` annotation with a name of `pirate_id` will allow the join table to point to a single row in the Pirate table).

We can also use the `@Cascade` annotation along with the `@ManyToMany` and `@JoinTable` annotations to tell Hibernate how to behave when we save an instance of the enclosing class - in the following example, we tell Hibernate to save the related entity in the relationship if we save an instance of the class in which we're using the annotation. So here, if we save a Raid along with a list of Pirate objects, Hibernate will both persist the Raid __and__ the list of Pirate objects to the database:

```java
@Entity
public class Raid {
  ...

  @ManyToMany
  @Cascade(org.hibernate.annotations.CascadeType.SAVE_UPDATE)
  @JoinTable(
          name = "pirates_raids",
          joinColumns = {@JoinColumn(name = "raid_id", nullable = false, updatable = false)},
          inverseJoinColumns = {@JoinColumn(name="pirate_id", nullable = false, updatable = false)}
  )
  private List<Pirate> pirates;

  ...
}
```

```java
@Entity
public class Pirate {
  ...
  @ManyToMany
  @Cascade(org.hibernate.annotations.CascadeType.SAVE_UPDATE)
  @JoinTable(
          name = "pirates_raids",
          joinColumns = {@JoinColumn(name = "pirate_id", nullable = false, updatable = false)},
          inverseJoinColumns = {@JoinColumn(name = "raid_id", nullable = false, updatable = false)}
  )
  private List<Raid> raids;

  ...
}
```

### Custom join tables to handle many-to-many relationships
In database terms, we solve the problems arising from many-to-many relationships by way of a join table, which results in two one-to-many relationships with the join table. When we use the `@ManyToMany` annotation along with the `@JoinTable` annotation, we ask Hibernate to manage the creation and use of a join table for us which will have an ID for each thing we're trying to join. 

For example, in the case of Pirates and Raids, we end up with a join table `pirates_raids` which has the ID of a Pirate and the ID of a Raid.

However, sometimes we want to store other properties in this join table - for example suppo

### Controlling infinite recursion when serializing to JSON
Note that the majority of the annotations we use on our model properties are simply an instruction to Spring/Hibernate and the underlying Jackson library as to how to handle relationships at the database layer, however sometimes we encounter issues deserializing (converting from JSON or another form to Java objects) and serializing (converting from Java to JSON or another form) objects that have relationships to other objects, which in turn have a reference back the way - leading to an infinite recursion problem.

This can be solved in various ways, however commonly we will either use the `@JsonIgnoreProperties` or `@JsonBackReference` annotation. Both these annotations cause slightly different behaviour.

In the following example using `@JsonBackReference` means that if we query the Ship table and return the data from a Spring Controller, Jackson will not attempt to serialize the list of pirates, that is to say it would be entirely excluded from the output:

```java
@Entity
public class Ship {
  ...

    @JsonBackReference
    @OneToMany(mappedBy = "ship", fetch = FetchType.LAZY)
    private List<Pirate> pirates;

  ...
}
```

The above model definition leads to an output of the following when returning all ships:

```json
[
  {
    "id": 1,
    "name": "The Flying Dutchman"
  },
  {
    "id": 2,
    "name": "The Black Pearl"
  },
  {
    "id": 3,
    "name": "The Black Pig"
  },
...
]
```

On the other hand, if we did want to include the list of pirates when querying our API for raids, we could use the `@JsonIgnoreProperties` annotation to tell Jackson not to try and serialize the ship field on the pirate class when returning a list of ships with their corresponding pirates (otherwise Jackson would try and get a Ship, then it's pirates, then for each pirate their ship, and then its list of pirates and so on, until the application throws an exception).

Note that we pass as an argument to the `@JsonIgnoreProperties` annotation the name of the Java class property (**not** the database column name) on the related class which points back to the class in which we're using the annotation. For example, here, we're annotating a property which denotes a relationship with the Pirate class. The Pirate class has a property on it called `ship` which denotes the relationship pointing back to the Ship class, so we pass to the `@JsonIgnoreProperties` annotation this property name:

```java
@Entity
public class Ship {
  ...

    @JsonIgnoreProperties({"ship"})
    @OneToMany(mappedBy = "ship", fetch = FetchType.LAZY)
    private List<Pirate> pirates;

  ...
}
```

The above model definition leads to an output of the following when returning all ships - this time the pirates related to each ship are included but Jackson doesn't try and go a step further by then getting all ships for those pirates:

```json
[
  {
    "id": 1,
    "name": "The Flying Dutchman",
    "pirates": [
      {
        "firstName": "John",
        "lastName": "Silver",
        "age": 55,
        "id": 2
      }
    ]
  },
  {
    "id": 2,
    "name": "The Black Pearl",
    "pirates": [
      {
        "firstName": "Jack",
        "lastName": "Sparrow",
        "age": 32,
        "id": 1
      }
    ]
  },
  ...
]
```

For more information on Jackson related annotations (Jackson is the library used by Spring and Hibernate to translate data from Java to JSON - called serializing or serialization and back to Java - called deserializing or deserialization) see the tutorials [here](https://www.baeldung.com/jackson).

### Do I need to have and annotate properties on both sides of one-to-many, many-to-one and many-to-many relationships?
It is only necessary to annotate on both sides (both classes) of a relationship if you want Hibernate to allow you to get from class A to class B and vice-versa. For example if you have a many-to-many relationship between Raid and Pirate (many pirates associated with many raids) and you use the `@ManyToMany` annotation, you would use this on a List of Pirates property in the Raid class and List of Raids in the Pirate class, allowing you to easily get access to all Pirates associated with a Raid and vice-versa.

The following class configurations support you being able to get a list of Pirates related to a Raid or a list of Raids related to a Pirate:

```java
@Entity
public class Raid {
  ...

  @JsonBackReference
  @ManyToMany
  @Cascade(org.hibernate.annotations.CascadeType.SAVE_UPDATE)
  @JoinTable(
          name = "pirates_raids",
          joinColumns = {@JoinColumn(name = "raid_id", nullable = false, updatable = false)},
          inverseJoinColumns = {@JoinColumn(name="pirate_id", nullable = false, updatable = false)}
  )
  private List<Pirate> pirates;

  ...
}
```

```java
@Entity
public class Pirate {
  ...

  @ManyToMany
  @Cascade(org.hibernate.annotations.CascadeType.SAVE_UPDATE)
  @JoinTable(
      name = "pirates_raids",
      joinColumns = {@JoinColumn(name = "pirate_id", nullable = false, updatable = false)},
      inverseJoinColumns = {@JoinColumn(name = "raid_id", nullable = false, updatable = false)}
  )
  private List<Raid> raids;

  ...
}
```

However, supposing you were only ever interested in being able to get all Pirates involved in a Raid but not so bothered about which Raids a Pirate was associated with, you would simply **not** include a list of Raids property in the Pirates class but just have a list of Pirates property in the Raid class. This also has the benefit that you don't need to worry about the infinite recursion problem since when Pirates are fetched for a Raid, Hibernate will not try and get Raids for a Pirate, since there isn't any list of Raids property on the Pirate class:

```java
@Entity
public class Raid {
  ...
  @ManyToMany
  @Cascade(org.hibernate.annotations.CascadeType.SAVE_UPDATE)
  @JoinTable(
          name = "pirates_raids",
          joinColumns = {@JoinColumn(name = "raid_id", nullable = false, updatable = false)},
          inverseJoinColumns = {@JoinColumn(name="pirate_id", nullable = false, updatable = false)}
  )
  private List<Pirate> pirates;

  ...
}
```

## Repository interfaces
Ensure you annotate your repository interface with `@Repository` which will indicate to Spring that it should manage an instance of this repository that you can make available using the `@Autowired` annotation. For example:

```java
package com.example.codeclan.pirateservice.repository;

import com.example.codeclan.pirateservice.models.Pirate;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PirateRepository extends JpaRepository<Pirate, Long> {
}

```

Here, we define a new repository interface which extends from the Spring `JpaRepository` interface - meaning we will get for free methods like `findById` and `save`. Note that when we extend this interface, we need to tell Spring the type of repository - that is to say the type of Java object we want to be able to perform CRUD operations with - in this case `Pirate` and as a second argument, the type of this entity's identifier - in this case `Long`.

### Derived queries
Whilst our repository interfaces give us some standard behaviour like `save`, `findAll` and `delete` we sometimes want to do something more exciting like find by a specific property other than the ID or only get the top 3 results. To support this, Spring and Hibernate offers derived query syntax whereby you can write a method with no body in your repository interface and, as long as you follow the correct pattern, a SQL query will be generated and executed for you automtically.

Derived query methods should be written in the correct repository based on the thing being returned. For example, if your method is returning a Pirate or List<Pirate>, it should be in the PirateRepository.

The structure starts with one of `find`, `read`, `query`, `count` or `get` followed by a condition (multiple conditions can be used, separated by `And` or `Or` as you'll see in the subsequent examples).

Conditions can be based on a property in the context class - see the following examples:

```java

// Find Pirates whose first name is equal to the provided argument
List<Pirate> findByFirstName(String nameToFind);

// For readability we can optionally use 'Is' or 'Equals' to achieve the same thing
// the following queries do the exact same thing as the first example
List<Pirate> findByFirstNameIs(String nameToFind);
List<Pirate> findByFirstNameEquals(String nameToFind);

// Find Pirates where the first name does NOT equal the provided argument- the following queries
// do the same thing
List<Pirate> findByFirstNameNot(String nameToExclude);
List<Pirate> findByFirstNameIsNot(String nameToExclude);

// Count Pirates whose age is greater than 30 - use `LessThan` for age < minimumAge
List<Pirate> countByAgeGreaterThan(int minimumAge);

// Count Pirates whose age is greater than or equal to 30. use `LessThanEqual` for age <= minimumAge
List<Pirate> countByAgeGreaterThanEqual(int minimumAge);

// Find all Pirates ordered by their age, ascending or in the second method, descending
List<Pirate> findByOrderByAge();
List<Pirate> findByOrderByAgDesc();

// Find all Pirates whose ages are between two values
List<Pirate> findByAgeBetween(int minAge, int maxAge);

// Find all Pirates whose lastName is in a list of names
List<Pirate> findByLastNameIn(List<String> lastNamesToFind);

// Find all Pirates who don't have a Ship (i.e. the Ship is null) and then those that do have a
// Ship (i.e. the Ship is not null)
List<Pirate> findByShipIsNull();
List<Pirate> findByShipIsNotNull();

// Find by a boolean property being true or false
List<Pirate> findByAliveIsTrue();
List<Pirate> findByAliveIsFalse();

// Find the first 1 or 3 results (`First` can be replaced wth `Top`)
List<Pirate> findFirstByAge(int ageToMatch);
List<Pirate> findFirst3ByAge(int ageToMatch);

// Find pirates whose first name starts with, ends with or contains a string
List<Pirates> findByFirstNameStartingWith(String prefix);
List<Pirates> findByFirstNameEndingWith(String suffix);
List<Pirates> findByFirstNameContaining(String subString);
List<Pirates> findByFirstNameLike(String pattern);

// Add `IgnoreCase` for case insensitive search:
List<Pirates> findByFirstNameStartingWithIgnoreCase(String prefix);
List<Pirates> findByFirstNameEndingWithIgnoreCase(String suffix);
List<Pirates> findByFirstNameContainingIgnoreCase(String subString);
```

We can also write derived queries based on properties on related classes (e.g. properties we've annotated to indicate a relationship):

```java

// Assuming Pirate has a property `ship` and Ship has a property `name`, find pirates who belong
// to a ship with the provided name
List<Pirate> findByShipName(String shipName);

// Assuming Pirate has a property `raids` and Raid has a property `location`, find pirates who have
// been in a Raid for a given location
List<Pirate> findByRaidsLocation(String location);
```

We can also chain together multiple conditions using `And` and `Or`:

```java

// Find pirates with first AND last name
List<Pirate> findByFirstNameAndLastName(String firstName, String lastName);

// Find pirates either by ship name OR raid location
List<Pirate> findByShipNameOrRaidsLocation(String shipName, String raidsLocation);
```

See [here](https://www.baeldung.com/spring-data-derived-queries) for some more information and [here](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/#repository-query-keywords) for a full list of available keywords that can be used in derived queries.

### Custom queries
Sometimes it isn't possible to achieve what we want using a derived query and we'd prefer to use our own custom SQL query. To do this we can add methods to our repository interfaces annotated with the `@Query` annotation which allows us to write our own custom SQL rather than using Hibernate's automatically generated SQL. Note that by default, the SQL language expected is JPQL (Java Persistence Query Language - which looks like the SQL you might be used to be different. We need to tell Hibernate we wish to use the SQL we're used to by passing the `nativeQuery = true` argument to the annotation.

The following shows two arbitrary examples of defining our own custom queries. Note that the return type of the method **must** match what will be returned by the query - so if our query is getting potentially multiple Pirate objects, it makes sense that our method returns a type of `List<Pirate>`. Similarly, if we expect our method to return just one (or potentially one) Pirate by making our method return `Optional<Pirate>` we should ensure the SQL query might not return more than one result or we'll potentially encounter an exception at some point.

Placeholders for arguments to your methods that you want to be used in the SQL query are defined in the query using `?n` where `n` is the number of the argument starting at 1. So if we had two placeholders in the query, these would be written as `?1` and `?2` respectively, where Hibernate would inject two method arguments in the same order.

```java
@Repository
public interface PirateRepository extends JpaRepository<Pirate, Long> {
    @Query(value = "SELECT * FROM pirates", nativeQuery = true)
    List<Pirate> customQueryGetAll();

    @Query(value = "SELECT * FROM pirates WHERE first_name = ?1 LIMIT 1", nativeQuery = true)
    Optional<Pirate> customQueryGetFirstWithName(String name);
}
```

## Controller annotations
There are various ways we can indicate to Spring that a class will act as a set of controller endpoints which will respond to web requests to given addresses, however commonly this is achieved by annotating such a class with `@RestController` and then defining one or more controller methods within the class. For example a controller class with a single endpoint for retrieving all pirates:

```java
@RestController
public class PirateController {
    @Autowired
    PirateRepository pirateRepository;

    @GetMapping(value = "/pirates")
    public ResponseEntity<List<Pirate>> getAllPirates(){
        return new ResponseEntity<>(pirateRepository.findAll(), HttpStatus.OK);
    }
}
```

Controller endpoints following such a pattern will be annotated with one of `@DeleteMapping`, `@GetMapping`, `@PutMapping` or `@PostMapping` for accepting an HTTP request with a method of DELETE, GET, PUT or POST respectively. These annotations should normally be passed a `value` argument indicating what URL path Spring should use to match up an incoming request with. Optionally, the path can include one or more path variables as a placeholder for some value such as an ID.

For example `@GetMapping(value = "/pirates")` will match on a relative URL of `/pirates` and `@GetMapping(value = "/pirates/{id}")` will match on a URL like `/pirates/abc` or `/pirates/1`.

### Accessing a URL path variable
When such a path variable placeholder like `{id}` is used, it can be accessed in the body of the controller method by having the method accept a parameter of an appropriate type and annotating that parameter with `@PathVariable`. For example, in the case of the `@GetMapping(value = "/pirates/{id}")` the following allows us to get access to the id part of the URL through the parameter `idFromPath`:

```java
@GetMapping(value = "/pirates/{id}")
  public ResponseEntity getPirate(@PathVariable Long idFromPath){
      return new ResponseEntity<>(pirateRepository.findById(idFromPath), HttpStatus.OK);
  }
```

### Accessing the request body
When we want to be able to access the body of a request in one of our controller methods, we simply have the controller method accept a parameter of an appropriate type and annotate that parameter with `@RequestBody` - Spring will do the rest. For example, if we expected our endpoint to be called with details of a Pirate, we could access the Pirate object inside the controller method like so, here Spring automatically converts a JSON-like body to a Java Pirate object (assuming the structure and data types are correct) and injects into the parameter `pirateFromRequestBody`:

```java
@PostMapping(value = "/pirates")
public ResponseEntity<Pirate> postPirate(@RequestBody Pirate pirateFromRequestBody){
    pirateRepository.save(pirateFromRequestBody);
    return new ResponseEntity<>(pirateFromRequestBody, HttpStatus.CREATED);
}
```

### Accessing query parameters
Sometimes we may expect a request to be sent with query parameters (effectively key-value pairs defined in the URL e.g. `filterby` and `age` are key, value respectively in the URL `somedomain.com/staff?filterby=age`). If we want to be able to access these in a Spring controller method, we simply declare that the method accepts a parameter of the appropriate type and annotate it with `@RequestParam`.

Taking the `somedomain.com?filterBy=age` example, our controller method might look like:

```java
@GetMapping(value = "/staff")
public ResponseEntity getStaff(@RequestParam String filterBy) {
  ...
}
```

Note that by default, Spring will treat the request parameter as mandatory and will expect the request to use the same query parameter key as the method parameter used. If we wish to mark the parameter as optional and/or specify a different name, we simply pass required and name arguments to the annotation as required:

```java
@GetMapping(value = "/staff")
public ResponseEntity getStaff(@RequestParam(required = false, name = "filter_by") String filterBy) {
  ...
}
```

In the second example, we made the parameter optional and told Spring to get from the request a key of `filter_by` instead of `filterBy`.

## Test annotations
There are many annotations we may use when writing tests for our Spring application, but commonly we will annotate the test classes with `@SpringBootTest` which, amongst other things, gives us a test Spring application context and also allows us to specify a profile which should be active during test execution.

In the following example, we annotate the test class with `@SpringBootTest` to indicate the tests within should be executed in a test Spring application context and we also apply the `@ActiveProfiles` annotation allowing us to tell Spring that when creating the application context, the active profile should be set to `test` (this can be helpful if we have any components such as a data loader that we want to say should not be run if the active profile is `test`). Note that the `@ActiveProfiles` annotation is optional, we don't have to specify an active profile:

```java
@ActiveProfiles("test")
@SpringBootTest
public class PirateserviceApplicationTests {
  ...
}
```

## Spring components
When we want Spring to be able to automatically create and manage a shared instance of a given class for us, we can annotate the class with `@Component`. If we do this, we need to ensure that anything required to construct an instance of this class is instantiated as part of the class constructor, or something that Spring can autowire for us - such as other Spring components.

In the following example, we make sure to avoid a Null Pointer Exception by instantiating the someStrings List but assuming the PirateRepository is a `@Repository` annotated repository interface, Spring knows how to pass an instance of this to our MyClass constructor:

```java
@Component
public class MyClass {
  private List<String> someStrings;
  private PirateRepository pirateRepo;

  public MyClass(PirateRepository pirateRepo) {
    someStrings = new ArrayList<>();
    this.pirateRepo = pirateRepo;
  }
}
```

The same thing could be achieved using `@Autowired` - the main difference being the impact on how easily we can test the MyClass class:

```java
@Component
public class MyClass {
  private List<String> someStrings = new ArrayList<>();

  @Autowired
  private PirateRepository pirateRepo;
}
```

## Dependency injection annotation
If we want to automatically have Spring make available an instance of something it manages (including but not limited to classes or interfaes which were annotated with `@Repository`, `@Component`, `@Service`, `@Bean`) we can declare a property of a type we need an instance of and annotate it with `@Autowired`, Spring will inject an instance of this thing into the property's variable for us. Note that if Spring encounters problems trying to create an instance of the thing we want we may get a `Failed to load application context` exception in our console at application startup.

The following both show examples of how we can ask Spring to make an instance of the PirateRepository available. Note that in order for this to work, the enclosing class needs to be something managed by Spring, e.g. a test class annotated with `@SpringBootTest` or a class annotated with `@Component`, `@Service` for example:

```java
@SpringBootTest
public class PirateserviceApplicationTests {

	@Autowired
	PirateRepository pirateRepository;

  ...
}
```

```java
@Component
public class DataLoader implements ApplicationRunner {

    @Autowired
    PirateRepository pirateRepository;

    ...
}
```

## Additional Resources
- [Baeldung Spring Tutorials](https://www.baeldung.com/spring-tutorial)
- [Baeldung Jackson Tutorials](https://www.baeldung.com/jackson)
- [Spring Boot Reference Documentation](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/)
- [Spring Documentation](https://spring.io/)
- [IntelliJ Spring Guides](https://www.jetbrains.com/help/idea/spring-support.html)